package ch.capi.utils{	import flash.errors.IllegalOperationError;			/**	 * Represents Matcher. A <code>Matcher</code> provides some facilty methods to do replacement	 * using regular expressions.	 * 	 * @example	 * <listing version="3.0">	 * var re:RegExp = /\${(.*?)}/g;	 * var sr:String = "This is a ${TEST} value and ${THAT} is another one => ${YEAH}";	 *	 * var m:Matcher = new Matcher(re, sr);	 * while (m.find())	 * {	 *		trace(m.group(1));	 *		m.appendReplacement("REPLACED");	 * }	 * m.appendTail();	 * trace(m.toString()); //This is a REPLACED value and REPLACED is another one => REPLACED	 * </listing>	 * 	 * @author		Cedric Tabin - thecaptain	 * @version		1.0	 */	public class Matcher	{		//---------//		//Constants//		//---------//				//---------//		//Variables//		//---------//		private var _regexp:RegExp;		private var _source:String;		private var _count:int = 0;				private var _replaced:String = null;		private var _lastIndex:uint = 0;		private var _match:Object = null; //object of each match				//-----------------//		//Getters & Setters//		//-----------------//				/**		 * Defines the <code>RegExp</code> used.		 */		public function get regexp():RegExp { return _regexp; }				/**		 * Defines the source <code>String</code>.		 */		public function get source():String { return _source; }				/**		 * Defines the last index of the replacement into the source <code>String</code>.		 */		public function get lastIndex():uint { return _lastIndex; }				/**		 * Defines the number of matching <code>String</code> found. This value is updated		 * each time the method <code>find()</code> is called and there is a matching <code>String</code>.		 */		public function get count():int { return _count; }				//-----------//		//Constructor//		//-----------//				/**		 * Creates a new <code>Matcher</code> object.		 * 		 * @param	regexp		The regular expression to use over the source <code>String</code>.		 * @param	source		The source <code>String</code> to apply the <code>Matcher</code>.		 */		public function Matcher(regexp:RegExp, source:String):void		{			_regexp = regexp;			_source = source;		}				//--------------//		//Public methods//		//--------------//		/**		 * Find the next occurence of the <code>RegExp</code>.		 * 		 * @return	<code>true</code> if a match has been found.		 */		public function find():Boolean		{			_match = _regexp.exec(_source);			if (_match != null)			{				_count++;				return true;			}						return false;		}				/**		 * Retrieves the specified group index specified by the parenthesis. If the index is out of bounds,		 * then an error is thrown.		 * 		 * @param	id		The group id. 0 means the entire matching pattern.		 * @return	The matching <code>String</code>.		 */		public function group(id:uint=0):String		{			if (id >= _match.length) throw new IllegalOperationError("Id is out of bound : "+id);			return _match[id];		}				/**		 * Retrieves the number of groups into the matching <code>RegExp</code>. This value contains also the group		 * 0 which is the whole matching <code>String</code>.		 * 		 * @return	The number of groups.		 */		public function groups():int		{			if (_match == null) throw new IllegalOperationError("There is no current match (find called ?)");			return _match.length;		}		/**		 * Count all the matching <code>String</code> into the source <code>String</code>. This method is useful		 * if you need to know how many matching there are before calling n times the <code>find()</code> method.		 * 		 * @return	The number of matching <code>String</code>.		 */		public function countAll():int		{			var li:int = _regexp.lastIndex;			if (li >= _source.length) return _count;						var cnt:int = 0;			_regexp.lastIndex = 0;			while(_regexp.exec(_source) != null) cnt++;			_regexp.lastIndex = li;						return cnt;		}				/**		 * Reset this <code>Matcher</code>.		 */		public function reset():void		{			_count = 0;			_lastIndex = 0;			_replaced = null;			_match = null;			_regexp.lastIndex = 0;		}		/**		 * Replaces the current match by the specified value.		 * 		 * @param	value	The value to set.		 * @return	The updated <code>String</code>.		 * @see		#appendTail()	appendTail()		 */		public function appendReplacement(value:String):String		{			if (_match == null) throw new IllegalOperationError("There is no current match (find called ?)");						//calculates indexes and replace the match			var startIndex:int = _match.index;			var endIndex:int = _regexp.lastIndex;						if (_replaced == null) _replaced = "";			_replaced += _source.substring(_lastIndex, startIndex) + value;			_lastIndex = endIndex;						return _replaced;		}				/**		 * Appends the end of the source <code>String</code> to the updated <code>String</code>.		 * 		 * @return	The complete updated <code>String</code>.		 * @see		#appendReplacement()	appendReplacement()		 */		public function appendTail():String		{			if (_replaced == null) _replaced = "";			_replaced += _source.substring(_lastIndex, _source.length);						return _replaced;		}		/**		 * Returns the modified source <code>String</code> if the <code>find()</code> and <code>replaceMatch()</code>		 * methods have been used.		 */		public function toString():String		{			return _replaced;		}		//-----------------//		//Protected methods//		//-----------------//				//---------------//		//Private methods//		//---------------//	}}